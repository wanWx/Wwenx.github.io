{"meta":{"title":"IIssWan's Notes","subtitle":"Quick notes","description":"这是一个假的程序猿","author":"wanWx","url":"http://wanWx.github.io"},"pages":[{"title":"","date":"2018-04-03T14:51:29.732Z","updated":"2017-05-10T03:23:15.147Z","comments":true,"path":"404.html","permalink":"http://wanWx.github.io/404.html","excerpt":"","text":""},{"title":"分类","date":"2017-05-10T02:41:11.000Z","updated":"2017-05-10T02:42:19.039Z","comments":true,"path":"categories/index.html","permalink":"http://wanWx.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-05-10T05:42:54.000Z","updated":"2017-05-10T05:51:27.024Z","comments":true,"path":"tags/index.html","permalink":"http://wanWx.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Node.js学习-第二阶段-Express框架学习","slug":"Node-js学习-第二阶段-Express框架学习","date":"2018-10-08T14:23:37.000Z","updated":"2019-02-16T02:06:41.052Z","comments":true,"path":"2018/10/08/Node-js学习-第二阶段-Express框架学习/","link":"","permalink":"http://wanWx.github.io/2018/10/08/Node-js学习-第二阶段-Express框架学习/","excerpt":"Express入门Express 是node 第三方框架，大家都知道，框架的意义就在于能大大简化程序地开发。那么我们就看一下Express是怎么简化node程序开发的。","text":"Express入门Express 是node 第三方框架，大家都知道，框架的意义就在于能大大简化程序地开发。那么我们就看一下Express是怎么简化node程序开发的。 Express安装、配置、接受请求、响应安装Express框架：1npm install --save express –save参数，表示自动修改package.json文件，自动添加依赖项。 express用法很简单，按照咱们以前原生的写法，可能需要一个http.creatServer等等等等的。 在这里不用，直接： 创建服务 1var server = express(); 监听端口1server.listen(8080); 处理请求12345server.use(&apos;目录&apos;,function(req,res)&#123;&#125;) // 挂载中间件用的，默认挂载在根目录/里面包含3种方法send() // 可以写json 数据write() // 与原来的write方法一样，只能写出String/Bufferend() // 与原来一样 3种请求方法 GET请求例如访问：http://localhost:8080/?name=萨朗和哟123server.get(&apos;/&apos;, function(req, res)&#123; console.log(req.query.name);//输出：萨朗和哟&#125;); POST请求1234const bodyParser = require(&apos;body-parser&apos;); // 需要使用中间件进行解析server.use(bodyParser.urlencoded(&#123;extended: false&#125;));//解析POST数据req.body //POST请求的数据 USE请求1234server.use(&apos;/&apos;, function(req, res)&#123;res.send(&apos;hello express&apos;);// res.end(); 使用send()方法返回时，可以省略此行，&#125;); 完整例子1234567891011121314151617181920212223242526const express = require(&apos;express&apos;);var server = express();//用户数据var users = &#123; &apos;aaa&apos;:&apos;123456&apos;, &apos;bbb&apos;:&apos;654321&apos;, &apos;ccc&apos;:&apos;987655&apos;&#125;;server.get(&apos;/login&apos;,function(req,res)&#123; var user = req.query[&apos;user&apos;]; var pass = req.query[&apos;pass&apos;]; if(users[user] == null)&#123; res.res.send(&#123;ok:false,mas:&apos;此用户不存在&apos;&#125;) &#125;else&#123; if(users[user]!=pass)&#123; res.send(&#123;ok:false,mas:&apos;密码错了&apos;&#125;) &#125;else&#123; res.send(&#123;ok:true,msg:&apos;成功&apos;&#125;) &#125; &#125;&#125;)server.listen(8080) res扩展函数1234567res.download('./xxx.txt') // 下载文件res.json(&#123;&#125;) // 响应json对象res.jsonp(数据) // 配合jsonp 要求客户端请求的时候也是jsonp的方式, 并且callback=xxxres.redirect() // 重定向 301是永久重定向, 302临时重定向res.send() // 发送字符串数据自动加content-typeres.sendFile() // 显示一个文件res.sendStatus() // 响应状态码 服务端处理错误和404页面找不到 404页面响应router.all(&#39;*&#39;,()=&gt;{} ) 触发错误 next(err); 处理错误 app.use( 4参数函数 ) nodemon 修改代码自动重启 安装全局命令行工具 npm i -g nodemon 进入到指定目录命令行 nodemon ./xxx.js 手动触发重启，在命令行输入 rs回车 Cookie SessionCookie 在浏览器保存一些数据，每次请求都会带过来 受客户端控制，不安全，有限（4K7） 在cookie中有一个session的ID，服务器利用此ID找到session文件进行操作 发送cookie:12res.secret = &apos;字符串&apos; // cookie签名res.cookie(名字，值，&#123;path : &apos;/&apos;, maxAge: 毫秒， signed: true&#125;); 读取cookie:123var cookieParser = require(&apos;cookie-parser&apos;);server.use(cookieParser()); // 未签名的cookieserver.use(cookieParser(签名)); // 签名的cookie 1234567891011const cookieParser = require(&apos;cookie-parser&apos;);server.use(cookieParser());server.use(&apos;/&apos;, function(req, res)&#123; req.secret = &apos;ffdkfjf&apos;; // 在server.use(cookieParser(签名))时候可以省略 res.cookie(&apos;user&apos;, &apos;444&apos;, &#123;signed : true&#125;); // signed为是否签名 req.cookies; // 未签名版 req.signedCookies; // 签名版 res.send(&quot;hello cookie&quot;);&#125;); 删除cookie:1res.clearCookie(&apos;cookie的名&apos;); Session session – 保存数据，保存在服务端 安全 基于cookie实现的，不能独立存在12345678const cookieSession = require(&apos;cookie-session&apos;);server.use(cookieSession(&#123; name : &apos;session&apos;, //cookie名 //签名数组（越多越安全），每次请求都会进行循环下一个 keys : [&apos;aaa&apos;, &apos;bbb&apos;, &apos;ccc&apos;], maxAge: 24*3600*1000 //cookie存活时间（单位毫秒）&#125;));","categories":[{"name":"Node","slug":"Node","permalink":"http://wanWx.github.io/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://wanWx.github.io/tags/Node/"}]},{"title":"Node.js学习-第一阶段-http模块及文件操作","slug":"Node-js学习-第一阶段-http模块及文件操作","date":"2018-09-25T14:44:12.000Z","updated":"2018-09-26T15:48:14.886Z","comments":true,"path":"2018/09/25/Node-js学习-第一阶段-http模块及文件操作/","link":"","permalink":"http://wanWx.github.io/2018/09/25/Node-js学习-第一阶段-http模块及文件操作/","excerpt":"Node.js了解简单了解一下Node.js，众所周知现在是大前端时代，Javascript也可以在服务的运行了，这主要依靠Node.js。Node.js可以说是目前前端涉足后端的最佳技能之一了，早在最初，前端开发一直处于尴尬的“页面仔”的定位中，直到后来大家开始重视前后端开发分离，从工程到团队两个角度都分开，后端偏向单纯的API接口，前端复制调用API接口进行展示和业务调用。现在Node.js的出现意味则前端开发可以从前端到后端整套开发都可以包了。","text":"Node.js了解简单了解一下Node.js，众所周知现在是大前端时代，Javascript也可以在服务的运行了，这主要依靠Node.js。Node.js可以说是目前前端涉足后端的最佳技能之一了，早在最初，前端开发一直处于尴尬的“页面仔”的定位中，直到后来大家开始重视前后端开发分离，从工程到团队两个角度都分开，后端偏向单纯的API接口，前端复制调用API接口进行展示和业务调用。现在Node.js的出现意味则前端开发可以从前端到后端整套开发都可以包了。 安装及配置省略了以后再补(PS:主要我懒得写了) nodeJs之http系统模块12345678const http = require(&apos;http&apos;); // 引入http模块var server = http.createServer(function (req, res) &#123; // req:请求对象 和 res: 响应对象 res.write(&apos;404&apos;); // 需要传递给客户端的内容 res.end(); // 表示此次请求已处理完成。&#125;);server.listen(8080); // http.listen() 方法就可以让该HTTP服务器在指定端口监听 nodeJs之fs文件模块简单贴代码讲解吧读取文件1234567891011121314151617const http = require(&apos;http&apos;);const fs = require(&apos;fs&apos;); // 引入fs文件模块var server = http.createServer(function (req, res) &#123; var file_name = &apos;./www&apos; + req.url; fs.readFile(file_name, function(err, data) &#123; // 第一个参数是文件的路径 if (err) &#123; res.write(&apos;404&apos;); &#125; else &#123; res.write(data); &#125; res.end(); &#125;);&#125;);server.listen(8080); 写入文件12345const fs = require(&apos;fs&apos;);fs.writeFile(&apos;aaa.txt&apos;,&apos;l love you&apos;, function(err) &#123; // 文件名，内容 console.log(err)&#125;); 数据解析就目前来说，前台发送数据请求主要是from、Ajax、jsonp三种主流，当然还有其他请求方式，这里不作扩展，但是不管怎样，前台向后台请求数据都是通过http协议，所以只要数据拿到了，对于后台来说都没什么区别，可能细节上有略微差别，就像你点外卖，不管外卖小哥是骑摩托车还是电动车，你收到吃的没问题就可以了。 请求方式-Get请求方式 Get 数据是在url中 数据量最多32Kget数据后缀一般是user=name&amp;pass=123456&amp;age=18,这种格式叫querystring(查询字符串)下面第一种解析get请求方式用的就是querystring模块123456789101112131415const http = require(&apos;http&apos;);const querystring = require(&apos;querystring&apos;); // Querystring模块 用于格式化解析json字符串http.createServer(function(req,res)&#123; var GET = &#123;&#125;; if ( req.url.indexof(&apos;?&apos;) != 1 ) &#123; var arr = req.url.split(&apos;?&apos;); // 分割url字符串 var url = arr[0]; // arr[0] 切割后字符串=&gt;地址 GET = querystring.parse(arr[1]); // arr[1] 切割后字符串=&gt;数据=&gt;querystring.parse反序列化为一个对象。 &#125; else &#123; var url = req.url; &#125; console.log(url,GET); res.write(&apos;aaa&apos;); res.end();&#125;).listen(8080); 第二种 url模块相对于第一种用split自己切割（PS:太麻烦了有木有！！），这个url模块直接就帮助我们解析了url地址至于怎么用呢var obj = url.parse(&#39;地址&#39;, true);在这个地址后加上个true,出来的query自然而然的就是解析成json格式的数据1234567891011121314Url模块返回结果 &#123; protocol: &apos;http:&apos;, slashes: true, auth: null, host: &apos;www.baidu.com&apos;, port: null, hostname: &apos;www.baidu.com&apos;, hash: null, search: &apos;?uname=guoyu&amp;age=27&amp;sex=male&apos;, query: &apos;uname=guoyu&amp;age=27&amp;sex=male&apos;, pathname: &apos;/index.html&apos;, path: &apos;/index.html?uname=guoyu&amp;age=27&amp;sex=male&apos;, href: &apos;http://www.baidu.com/index.html?uname=guoyu&amp;age=27&amp;sex=male&apos; &#125; 12345678910const http = require(&apos;http&apos;);const urlLib = require(&apos;url&apos;);http.createServer(function (req, res) &#123; var obj = urlLib.parse(req.url, true); var url = obj.pathname; // 地址 var GET = obj.query; // 数据 console.log(url,GET); res.write(&apos;aaa&apos;); res.end();&#125;).listen(8080); 请求方式-POST 数据大小可以达到1个G首先说明一下，既然POST请求数据可能会达到1个G，所以它并不是一次性塞过来的，所以这个时候需要做的就是把数据切成一小块一小块req.on(&#39;data&#39;,function(data){ }) 每当数据到达一段，他就会执行一次req.on(&#39;end&#39;,function{}) 数据全部到达以后执行;两者结合起来12345678910const http = require(&apos;http&apos;);http.createServer(function (req, res) &#123; var str = &apos;&apos;; // 这个位置是用了一个字符串的形式接受，如果是媒体类型就有问题 var i = 0; req.on(&apos;data&apos;,function(data)&#123; console.log(`第$&#123;i++&#125;次收到数据`); str+=data; &#125;); req.on(&apos;end&apos;,function()&#123;&#125;)&#125;).listen(8080)； 结合前面的Get请求方式和文件操作模块12345678910111213141516171819202122232425262728const http = require(&apos;http&apos;);const querystring = require(&apos;querystring&apos;);const fs = require(&apos;fs&apos;); const urlLib = require(&apos;url&apos;);http.createServer(function(req,res)&#123; //GET var obj = urlLib.parse(req.url,true); var url = obj.pathname; const GET = obj.query; //POST var str = &apos;&apos;; var i = 0; req.on(&apos;data&apos;,function(data)&#123; str+=data; &#125;); req.on(&apos;end&apos;,function()&#123; // 接收到全部数据后 var POST = querystring.parse(str); // 序列化得到POST数据 console.log(url,GET,POST); //文件请求 var file_name=&apos;./www&apos;+url; fs.readFile(file_name,function(err,data)&#123; if(err)&#123; res.write(&apos;404&apos;) &#125; else &#123; res.write(data) &#125; res.end(); &#125;) &#125;) &#125;).listen(8080); 好了，以上就是对于Node.js中的http数据解析的概念整理了","categories":[{"name":"Node","slug":"Node","permalink":"http://wanWx.github.io/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://wanWx.github.io/tags/Node/"}]},{"title":"面试碰到的问题","slug":"面试碰到的问题","date":"2018-04-03T09:19:43.000Z","updated":"2018-04-03T14:38:23.520Z","comments":true,"path":"2018/04/03/面试碰到的问题/","link":"","permalink":"http://wanWx.github.io/2018/04/03/面试碰到的问题/","excerpt":"写这篇文章的初衷离职了一段时间，也参加了一些面试，突然发现自己的基础还比较薄弱，所以想通过整理一些碰到的面试问题，进行知识点的梳理，不排除分享一些HR问的骚操作。","text":"写这篇文章的初衷离职了一段时间，也参加了一些面试，突然发现自己的基础还比较薄弱，所以想通过整理一些碰到的面试问题，进行知识点的梳理，不排除分享一些HR问的骚操作。 js 遍历json对象JSON数组 (无规律)123456789101112131415var json = [ &#123;dd:&apos;SB&apos;,AA:&apos;东东&apos;,re1:123&#125;, &#123;cccc:&apos;dd&apos;,lk:&apos;1qw&apos;&#125;];for(var i=0,l=json.length;i&lt;l;i++)&#123; for(var key in json[i])&#123; console.log(key+&apos;:&apos;+json[i][key]); &#125;&#125;// dd:SB// AA:东东// re1:123// cccc:dd// lk:1qw JSON数组 (有规律)123456789101112var packJson = [ &#123;&quot;name&quot;:&quot;nikita&quot;, &quot;password&quot;:&quot;1111&quot;&#125;, &#123;&quot;name&quot;:&quot;tony&quot;, &quot;password&quot;:&quot;2222&quot;&#125;]; for(var p in packJson)&#123; //遍历json数组时，这么写p为索引，0,1 console.log(packJson[p].name + &quot; &quot; + packJson[p].password);&#125;;// nikita 1111// tony 2222 JSON对象1234567891011var myJson = &#123; &quot;name&quot;:&quot;caibaojian&quot;, &quot;password&quot;:&quot;1111&quot;&#125;; for(var p in myJson)&#123; //遍历json对象的每个key/value对,p为key console.log(p + &quot; &quot; + myJson[p]);&#125;// name caibaojian// password 1111 顺带举例几个JSON常用操作123456789101112131415161718192021JSON字符串：var isStr = &apos;&#123; &quot;name&quot;: &quot;wwx&quot;, &quot;sex&quot;: &quot;man&quot;&#125;&apos;;JSON对象：var isObj = &#123; &quot;name&quot;: &quot;wwx&quot;, &quot;sex&quot;: &quot;man&quot;&#125;;//字符串转JSONvar obj = JSON.parse(isStr);//JSON转字符串var str = JSON.stringify(obj);//JSON增加元素obj[&apos;key&apos;] = value;//JSON删除元素delete obj[&apos;key&apos;];//JSON按数字排序obj.sort(sortBy(&apos;key&apos;, false, parseInt));//JSON按字符串排序obj.sort(sortBy(&apos;key&apos;, false, String));","categories":[{"name":"面试中的翻车","slug":"面试中的翻车","permalink":"http://wanWx.github.io/categories/面试中的翻车/"}],"tags":[{"name":"面试整理","slug":"面试整理","permalink":"http://wanWx.github.io/tags/面试整理/"}]},{"title":"vue-cli结合Element-UI","slug":"vue-cli结合Element-UI","date":"2017-07-11T13:49:36.000Z","updated":"2017-07-11T14:49:03.508Z","comments":true,"path":"2017/07/11/vue-cli结合Element-UI/","link":"","permalink":"http://wanWx.github.io/2017/07/11/vue-cli结合Element-UI/","excerpt":"Element-Ui 的使用最近因为手上没有什么大的项目，就想着做点什么（果然是不喜欢闲下来的人），刚好瞄到后台小哥哥在用AmazeUi写一套后台管理系统，突然就萌生了想用vue一起写一套的想法啊！ 没办法，总不能浪费一个现成的练手项目吧，还有人免费提供接口（小小的可耻一下）","text":"Element-Ui 的使用最近因为手上没有什么大的项目，就想着做点什么（果然是不喜欢闲下来的人），刚好瞄到后台小哥哥在用AmazeUi写一套后台管理系统，突然就萌生了想用vue一起写一套的想法啊！ 没办法，总不能浪费一个现成的练手项目吧，还有人免费提供接口（小小的可耻一下）好了，既然要决定要用vue写后台管理系统，当然免不了找度娘瞧一瞧有没有适合的UI框架了。最后选了一番，选择了由饿了嘛Element-ui（主要是没找到比这适合的了）。下面讲一下两者一起使用需要做哪些准备。 1 Node.js的安装这个直接在node的官网下载就好因为国内npm速度受网速影响，所以建议安装一下淘宝镜像（可自行百度，是我偷懒了）后面npm全部可以改成用淘宝镜像cnpm 2 安装 vue-clinpm install -g vue-cli //这里推荐用-g全局安装一下 3 使用vue-cli初始化项目vue init webpack my-project(最后这个为你要建的项目文件名称) 4 进入目录cd my-project 5 安装Element-Uinpm i element-ui 6 安装依赖npm install你以为这样就好了嘛，其实并没有，我们需要去程序的入口文件main.js，去加载我们下载好的的Element-UI 7 开始运行npm run dev 8 访问地址localhost:8080 好了，至此就可以在vue文件中编写Element-ui的组件了，后面我会写一些在开发过程中遇过的坑了","categories":[{"name":"Vue","slug":"Vue","permalink":"http://wanWx.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://wanWx.github.io/tags/Vue/"}]},{"title":"Flex 布局","slug":"flex-box","date":"2017-06-06T14:14:30.000Z","updated":"2017-06-06T15:46:12.810Z","comments":true,"path":"2017/06/06/flex-box/","link":"","permalink":"http://wanWx.github.io/2017/06/06/flex-box/","excerpt":"一、Flex布局是什么？Flex是Flexible Box的缩写，意为 “弹性布局”（PS: 说起弹性布局，就好气啊，面试的时候HR问：“说说弹性布局”,而我一脸懵逼！！）,就是用来为盒装模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。123.box &#123; display: flex;&#125; 行内元素也可以使用Flex布局123.box &#123; display: inline-flex;&#125;","text":"一、Flex布局是什么？Flex是Flexible Box的缩写，意为 “弹性布局”（PS: 说起弹性布局，就好气啊，面试的时候HR问：“说说弹性布局”,而我一脸懵逼！！）,就是用来为盒装模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。123.box &#123; display: flex;&#125; 行内元素也可以使用Flex布局123.box &#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。1234.box &#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 1、flex布局基本概念（~~ 可能有点老掉牙了，但是很有用啊）在使用了Flex布局的元素，称为Flex容器，简称“容器”。它的所有子元素自动成为容器的成员，称为Flex项目（自我理解就是一个容器的放了很多小块，这些小块都归外面的容器爸爸管） 2、容器的属性2.1 flex-direction属性flex-direction属性觉得主轴的方向(即项目的排列方向)。123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 分别有4个值 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 2.2 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。它可能取三个值。（1）nowrap（默认）：不换行。（2）wrap：换行，第一行在上方。（3）wrap-reverse：换行，第一行在下方。 2.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 2.4 justify-content属性justify-content属性定义了项目在主轴上的对齐方式。它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 2.5 align-items属性align-items属性定义项目在交叉轴上如何对齐。123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 2.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。123.item &#123; order: &lt;integer&gt;;&#125; 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://wanWx.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://wanWx.github.io/tags/CSS/"}]},{"title":"vue基础知识-事件监听","slug":"20170601","date":"2017-06-01T14:45:34.000Z","updated":"2017-06-01T15:22:12.739Z","comments":true,"path":"2017/06/01/20170601/","link":"","permalink":"http://wanWx.github.io/2017/06/01/20170601/","excerpt":"事件监听你可以使用v-on指令来绑定并监听 DOM 事件。绑定的内容可以是一个当前实例上的方法 (后面无需跟括号) 或一个内联表达式。如果提供的是一个方法，则原生的 DOM event 会被作为第一个参数传入，同时这个 event 会带有 targetVM属性，指向触发该事件的相应的 ViewModel：","text":"事件监听你可以使用v-on指令来绑定并监听 DOM 事件。绑定的内容可以是一个当前实例上的方法 (后面无需跟括号) 或一个内联表达式。如果提供的是一个方法，则原生的 DOM event 会被作为第一个参数传入，同时这个 event 会带有 targetVM属性，指向触发该事件的相应的 ViewModel：1234&lt;div id=&quot;demo&quot;&gt; &lt;a v-on=&quot;click: onClick&quot;&gt;触发一个方法函数&lt;/a&gt; &lt;a v-on=&quot;click: n++&quot;&gt;触发一个表达式&lt;/a&gt;&lt;/div&gt; 123456789101112new Vue(&#123; el: &apos;#demo&apos;, data: &#123; n: 0 &#125;, methods: &#123; onClick: function (e) &#123; console.log(e.target.tagName) // &quot;A&quot; console.log(e.targetVM === this) // true &#125; &#125;&#125;) 执行表达式当在v-repeat 里使用v-on时，targetVM显得很有用，因为 v-repeat会创建大量子 ViewModel。但是，通过执行表达式的方式，把代表当前 ViewModel 数据对象的别名传进去，会更方便直观一些：12345&lt;ul id=&quot;list&quot;&gt; &lt;li v-repeat=&quot;item in items&quot; v-on=&quot;click: toggle(item)&quot;&gt; &#123;&#123;item.text&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 1234567891011121314new Vue(&#123; el: &apos;#list&apos;, data: &#123; items: [ &#123; text: &apos;one&apos;, done: true &#125;, &#123; text: &apos;two&apos;, done: false &#125; ] &#125;, methods: &#123; toggle: function (item) &#123; item.done = !item.done &#125; &#125;&#125;) 为什么要在 HTML 中写监听器？你可能会注意到整个事件监听的方式违背了 “separation of concern” 的传统理念。不必担心，因为所有的 Vue.js 时间处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护困难。实际上，使用 v-on 还有更多好处： 它便于在 HTML 模板中轻松定位 JS 代码里的对应方法实现。 因为你无须在 JS 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦。这会更易于测试。 当一个 ViewModel 被销毁时，所有的事件监听都会被自动移除。你无须担心如何自行清理它们。","categories":[{"name":"vue","slug":"vue","permalink":"http://wanWx.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://wanWx.github.io/tags/vue/"}]},{"title":"因为她不喜欢你啊","slug":"firstblogg","date":"2017-05-14T02:55:31.000Z","updated":"2017-05-14T04:52:17.089Z","comments":true,"path":"2017/05/14/firstblogg/","link":"","permalink":"http://wanWx.github.io/2017/05/14/firstblogg/","excerpt":"她不理你是对的，是为了你好，这个人不喜欢你，回应你只会害你陷得更深，事实上她还是不喜欢你，你会更伤心的。","text":"她不理你是对的，是为了你好，这个人不喜欢你，回应你只会害你陷得更深，事实上她还是不喜欢你，你会更伤心的。 心这个东西并不是你想要就能得到的，也不是你喜欢就该是你的，你伤心怎么怎么样…这些都是你的事情，和那个人没关系.","categories":[{"name":"随笔","slug":"随笔","permalink":"http://wanWx.github.io/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://wanWx.github.io/tags/随笔/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-05-10T13:32:41.053Z","updated":"2017-05-16T15:12:59.673Z","comments":true,"path":"2017/05/10/hello-world/","link":"","permalink":"http://wanWx.github.io/2017/05/10/hello-world/","excerpt":"之前一直想搭建属于自己的一个博客，但因为各种原因都不了了之(总要是懒),恰好最近比较闲，于是偷偷自己按网上资料，搭建了属于自己的博客。 至于为什么要自己搭建自己的博客…","text":"之前一直想搭建属于自己的一个博客，但因为各种原因都不了了之(总要是懒),恰好最近比较闲，于是偷偷自己按网上资料，搭建了属于自己的博客。 至于为什么要自己搭建自己的博客… hhhh,大概是为了装逼，同时自己搭建博客的话，样式的选择也比较自由，可以自己选择，不需要受限于各大平台。 好了，话就这么多…","categories":[{"name":"公告","slug":"公告","permalink":"http://wanWx.github.io/categories/公告/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://wanWx.github.io/tags/随笔/"},{"name":"vue","slug":"vue","permalink":"http://wanWx.github.io/tags/vue/"},{"name":"CSS","slug":"CSS","permalink":"http://wanWx.github.io/tags/CSS/"},{"name":"Javascript","slug":"Javascript","permalink":"http://wanWx.github.io/tags/Javascript/"},{"name":"Html","slug":"Html","permalink":"http://wanWx.github.io/tags/Html/"}]}]}