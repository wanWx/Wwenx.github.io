<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Node.js学习-第一阶段-http模块及文件操作]]></title>
    <url>%2F2018%2F09%2F25%2FNode-js%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5-http%E6%A8%A1%E5%9D%97%E5%8F%8A%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Node.js了解简单了解一下Node.js，众所周知现在是大前端时代，Javascript也可以在服务的运行了，这主要依靠Node.js。Node.js可以说是目前前端涉足后端的最佳技能之一了，早在最初，前端开发一直处于尴尬的“页面仔”的定位中，直到后来大家开始重视前后端开发分离，从工程到团队两个角度都分开，后端偏向单纯的API接口，前端复制调用API接口进行展示和业务调用。现在Node.js的出现意味则前端开发可以从前端到后端整套开发都可以包了。 安装及配置省略了以后再补(PS:主要我懒得写了) nodeJs之http系统模块12345678const http = require(&apos;http&apos;); // 引入http模块var server = http.createServer(function (req, res) &#123; // req:请求对象 和 res: 响应对象 res.write(&apos;404&apos;); // 需要传递给客户端的内容 res.end(); // 表示此次请求已处理完成。&#125;);server.listen(8080); // http.listen() 方法就可以让该HTTP服务器在指定端口监听 nodeJs之fs文件模块简单贴代码讲解吧读取文件1234567891011121314151617const http = require(&apos;http&apos;);const fs = require(&apos;fs&apos;); // 引入fs文件模块var server = http.createServer(function (req, res) &#123; var file_name = &apos;./www&apos; + req.url; fs.readFile(file_name, function(err, data) &#123; // 第一个参数是文件的路径 if (err) &#123; res.write(&apos;404&apos;); &#125; else &#123; res.write(data); &#125; res.end(); &#125;);&#125;);server.listen(8080); 写入文件12345const fs = require(&apos;fs&apos;);fs.writeFile(&apos;aaa.txt&apos;,&apos;l love you&apos;, function(err) &#123; // 文件名，内容 console.log(err)&#125;); 后面的持续更新]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试碰到的问题]]></title>
    <url>%2F2018%2F04%2F03%2F%E9%9D%A2%E8%AF%95%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[写这篇文章的初衷离职了一段时间，也参加了一些面试，突然发现自己的基础还比较薄弱，所以想通过整理一些碰到的面试问题，进行知识点的梳理，不排除分享一些HR问的骚操作。 js 遍历json对象JSON数组 (无规律)123456789101112131415var json = [ &#123;dd:&apos;SB&apos;,AA:&apos;东东&apos;,re1:123&#125;, &#123;cccc:&apos;dd&apos;,lk:&apos;1qw&apos;&#125;];for(var i=0,l=json.length;i&lt;l;i++)&#123; for(var key in json[i])&#123; console.log(key+&apos;:&apos;+json[i][key]); &#125;&#125;// dd:SB// AA:东东// re1:123// cccc:dd// lk:1qw JSON数组 (有规律)123456789101112var packJson = [ &#123;&quot;name&quot;:&quot;nikita&quot;, &quot;password&quot;:&quot;1111&quot;&#125;, &#123;&quot;name&quot;:&quot;tony&quot;, &quot;password&quot;:&quot;2222&quot;&#125;]; for(var p in packJson)&#123; //遍历json数组时，这么写p为索引，0,1 console.log(packJson[p].name + &quot; &quot; + packJson[p].password);&#125;;// nikita 1111// tony 2222 JSON对象1234567891011var myJson = &#123; &quot;name&quot;:&quot;caibaojian&quot;, &quot;password&quot;:&quot;1111&quot;&#125;; for(var p in myJson)&#123; //遍历json对象的每个key/value对,p为key console.log(p + &quot; &quot; + myJson[p]);&#125;// name caibaojian// password 1111 顺带举例几个JSON常用操作123456789101112131415161718192021JSON字符串：var isStr = &apos;&#123; &quot;name&quot;: &quot;wwx&quot;, &quot;sex&quot;: &quot;man&quot;&#125;&apos;;JSON对象：var isObj = &#123; &quot;name&quot;: &quot;wwx&quot;, &quot;sex&quot;: &quot;man&quot;&#125;;//字符串转JSONvar obj = JSON.parse(isStr);//JSON转字符串var str = JSON.stringify(obj);//JSON增加元素obj[&apos;key&apos;] = value;//JSON删除元素delete obj[&apos;key&apos;];//JSON按数字排序obj.sort(sortBy(&apos;key&apos;, false, parseInt));//JSON按字符串排序obj.sort(sortBy(&apos;key&apos;, false, String));]]></content>
      <categories>
        <category>面试中的翻车</category>
      </categories>
      <tags>
        <tag>面试整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli结合Element-UI]]></title>
    <url>%2F2017%2F07%2F11%2Fvue-cli%E7%BB%93%E5%90%88Element-UI%2F</url>
    <content type="text"><![CDATA[Element-Ui 的使用最近因为手上没有什么大的项目，就想着做点什么（果然是不喜欢闲下来的人），刚好瞄到后台小哥哥在用AmazeUi写一套后台管理系统，突然就萌生了想用vue一起写一套的想法啊！ 没办法，总不能浪费一个现成的练手项目吧，还有人免费提供接口（小小的可耻一下）好了，既然要决定要用vue写后台管理系统，当然免不了找度娘瞧一瞧有没有适合的UI框架了。最后选了一番，选择了由饿了嘛Element-ui（主要是没找到比这适合的了）。下面讲一下两者一起使用需要做哪些准备。 1 Node.js的安装这个直接在node的官网下载就好因为国内npm速度受网速影响，所以建议安装一下淘宝镜像（可自行百度，是我偷懒了）后面npm全部可以改成用淘宝镜像cnpm 2 安装 vue-clinpm install -g vue-cli //这里推荐用-g全局安装一下 3 使用vue-cli初始化项目vue init webpack my-project(最后这个为你要建的项目文件名称) 4 进入目录cd my-project 5 安装Element-Uinpm i element-ui 6 安装依赖npm install你以为这样就好了嘛，其实并没有，我们需要去程序的入口文件main.js，去加载我们下载好的的Element-UI 7 开始运行npm run dev 8 访问地址localhost:8080 好了，至此就可以在vue文件中编写Element-ui的组件了，后面我会写一些在开发过程中遇过的坑了]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex 布局]]></title>
    <url>%2F2017%2F06%2F06%2Fflex-box%2F</url>
    <content type="text"><![CDATA[一、Flex布局是什么？Flex是Flexible Box的缩写，意为 “弹性布局”（PS: 说起弹性布局，就好气啊，面试的时候HR问：“说说弹性布局”,而我一脸懵逼！！）,就是用来为盒装模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。123.box &#123; display: flex;&#125; 行内元素也可以使用Flex布局123.box &#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。1234.box &#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 1、flex布局基本概念（~~ 可能有点老掉牙了，但是很有用啊）在使用了Flex布局的元素，称为Flex容器，简称“容器”。它的所有子元素自动成为容器的成员，称为Flex项目（自我理解就是一个容器的放了很多小块，这些小块都归外面的容器爸爸管） 2、容器的属性2.1 flex-direction属性flex-direction属性觉得主轴的方向(即项目的排列方向)。123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 分别有4个值 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 2.2 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。它可能取三个值。（1）nowrap（默认）：不换行。（2）wrap：换行，第一行在上方。（3）wrap-reverse：换行，第一行在下方。 2.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 2.4 justify-content属性justify-content属性定义了项目在主轴上的对齐方式。它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 2.5 align-items属性align-items属性定义项目在交叉轴上如何对齐。123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 2.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。123.item &#123; order: &lt;integer&gt;;&#125; 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue基础知识-事件监听]]></title>
    <url>%2F2017%2F06%2F01%2F20170601%2F</url>
    <content type="text"><![CDATA[事件监听你可以使用v-on指令来绑定并监听 DOM 事件。绑定的内容可以是一个当前实例上的方法 (后面无需跟括号) 或一个内联表达式。如果提供的是一个方法，则原生的 DOM event 会被作为第一个参数传入，同时这个 event 会带有 targetVM属性，指向触发该事件的相应的 ViewModel：1234&lt;div id=&quot;demo&quot;&gt; &lt;a v-on=&quot;click: onClick&quot;&gt;触发一个方法函数&lt;/a&gt; &lt;a v-on=&quot;click: n++&quot;&gt;触发一个表达式&lt;/a&gt;&lt;/div&gt; 123456789101112new Vue(&#123; el: &apos;#demo&apos;, data: &#123; n: 0 &#125;, methods: &#123; onClick: function (e) &#123; console.log(e.target.tagName) // &quot;A&quot; console.log(e.targetVM === this) // true &#125; &#125;&#125;) 执行表达式当在v-repeat 里使用v-on时，targetVM显得很有用，因为 v-repeat会创建大量子 ViewModel。但是，通过执行表达式的方式，把代表当前 ViewModel 数据对象的别名传进去，会更方便直观一些：12345&lt;ul id=&quot;list&quot;&gt; &lt;li v-repeat=&quot;item in items&quot; v-on=&quot;click: toggle(item)&quot;&gt; &#123;&#123;item.text&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 1234567891011121314new Vue(&#123; el: &apos;#list&apos;, data: &#123; items: [ &#123; text: &apos;one&apos;, done: true &#125;, &#123; text: &apos;two&apos;, done: false &#125; ] &#125;, methods: &#123; toggle: function (item) &#123; item.done = !item.done &#125; &#125;&#125;) 为什么要在 HTML 中写监听器？你可能会注意到整个事件监听的方式违背了 “separation of concern” 的传统理念。不必担心，因为所有的 Vue.js 时间处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护困难。实际上，使用 v-on 还有更多好处： 它便于在 HTML 模板中轻松定位 JS 代码里的对应方法实现。 因为你无须在 JS 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦。这会更易于测试。 当一个 ViewModel 被销毁时，所有的事件监听都会被自动移除。你无须担心如何自行清理它们。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[因为她不喜欢你啊]]></title>
    <url>%2F2017%2F05%2F14%2Ffirstblogg%2F</url>
    <content type="text"><![CDATA[她不理你是对的，是为了你好，这个人不喜欢你，回应你只会害你陷得更深，事实上她还是不喜欢你，你会更伤心的。 心这个东西并不是你想要就能得到的，也不是你喜欢就该是你的，你伤心怎么怎么样…这些都是你的事情，和那个人没关系.]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[之前一直想搭建属于自己的一个博客，但因为各种原因都不了了之(总要是懒),恰好最近比较闲，于是偷偷自己按网上资料，搭建了属于自己的博客。 至于为什么要自己搭建自己的博客… hhhh,大概是为了装逼，同时自己搭建博客的话，样式的选择也比较自由，可以自己选择，不需要受限于各大平台。 好了，话就这么多…]]></content>
      <categories>
        <category>公告</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>CSS</tag>
        <tag>随笔</tag>
        <tag>Javascript</tag>
        <tag>Html</tag>
      </tags>
  </entry>
</search>